import re
import os
import json
import requests
import paramiko
from datetime import datetime

def clean_match_name_html(m):
     m = re.sub(r'\d{4}-\d{2}-\d{2}', '', m)
     m = re.sub(r'\d{2}-\d{2}', '', m)
     m = re.sub(r'\d{2}:\d{2}', '', m)
     if " vs " in m: m = m.replace(" vs ", " - ")
     return m.strip()

def generate_variations(outcomes_list):
    """
    Generates 27 variations from 3 lists of 3 outcomes.
    outcomes_list: [[o1a, o1b, o1c], [o2a...], [o3a...]]
    Returns list of 27 tuples: [(o1a, o2a, o3a), ...]
    """
    import itertools
    return list(itertools.product(*outcomes_list))

def calculate_stakes(budget, variations_count):
    """
    Simple flat stake: Budget / Variations
    """
    if variations_count == 0: return []
    stake = budget / variations_count
    return [stake] * variations_count

def calculate_dutching_stakes(budget, variations, odds_flat_list=None):
    """
    Calculates stakes for Equal Profit (Dutching).
    budget: Total Budget (e.g. 3000)
    variations: List of 27 tuples
    odds_flat_list: List of 9 floats [m1_o1, m1_o2, m1_o3, m2_o1...] 
                    or None (defaults to 1.9 for all)
    """
    if not variations: return []
    
    # Default odds if missing (effectively flat stake but via dutching formula)
    if not odds_flat_list or len(odds_flat_list) != 9:
        odds_flat_list = [1.9] * 9 # Default approx odd
        
    combos = []
    implied_prob_sum = 0
    
    # Reconstruct combo odds
    # Variations are generated by itertools.product(*outcomes)
    # So iteration order is: M1(0-2) -> M2(0-2) -> M3(0-2)
    # We map this to flat odds list indices:
    # M1 indices: 0, 1, 2
    # M2 indices: 3, 4, 5
    # M3 indices: 6, 7, 8
    
    # We need to iterate EXACTLY as itertools.product does to match 'variations' order
    # i range(3), j range(3), k range(3)
    
    calculated_stakes = []
    
    # 1. Calculate Total Implied Prob
    for i in range(3):
        for j in range(3):
            for k in range(3):
                # Indices in flat list
                idx1 = i
                idx2 = 3 + j
                idx3 = 6 + k
                
                odd1 = odds_flat_list[idx1]
                odd2 = odds_flat_list[idx2]
                odd3 = odds_flat_list[idx3]
                
                combo_odd = odd1 * odd2 * odd3
                if combo_odd <= 1.0: combo_odd = 1.01
                
                prob = 1 / combo_odd
                implied_prob_sum += prob
                
                combos.append(combo_odd)
                
    # 2. Calculate Constant Return
    constant_return = budget / implied_prob_sum
    
    # 3. Calculate Individual Stakes
    for combo_odd in combos:
        stake = constant_return / combo_odd
        calculated_stakes.append(stake)
        
    return calculated_stakes

def generate_express_html(m1, m2, m3, variations, stakes, m1_meta, m2_meta, m3_meta, timestamp):
    """
    Generates the HTML snapshot content.
    """
    n1, n2, n3 = clean_match_name_html(m1), clean_match_name_html(m2), clean_match_name_html(m3)
    
    # Outcomes strings
    # We don't have the "Expectation" strings passed here usually, but we can reconstruct or pass them differently.
    # For simplicity, we'll just format the meta reasoning.
    
    html_content = f"""
<!DOCTYPE html>
<html lang="ru">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Express Analysis #{timestamp}</title>
   <style>
       :root {{
           --bg: #ffffff;
           --text: #31333f;
           --accent: #ff4b4b;
           --card-bg: #f0f2f6; 
           --border: #e0e0e0;
       }}
       body {{ 
           font-family: "Source Sans Pro", -apple-system, sans-serif; 
           background-color: var(--bg); 
           color: var(--text); 
           padding: 20px; 
           max-width: 900px; 
           margin: 0 auto; 
       }}
       h1, h2, h3 {{ color: #0e1117; font-weight: 600; }}
       
       /* Legend Styles */
       .legend-card {{
           background-color: #e8f4f9; 
           border-radius: 8px;
           padding: 15px;
           margin-bottom: 15px;
           border: 1px solid #d1e4ee;
       }}
       .match-header {{
           font-weight: bold;
           color: #0068c9;
           margin-bottom: 8px;
           display: flex;
           align-items: center;
           gap: 10px;
       }}
       .match-info {{ margin-bottom: 5px; font-size: 0.95em; }}
       .icon {{ font-size: 1.2em; }}
       
       /* Checklist Styles */
       .checklist-container {{
           margin-top: 30px;
       }}
       .checklist-item {{
           padding: 10px 0;
           border-bottom: 1px solid #eee;
           display: flex;
           align-items: center;
           transition: 0.2s;
       }}
       .checklist-item:hover {{ background-color: #f9f9f9; }}
       .checklist-item input[type="checkbox"] {{
           width: 20px;
           height: 20px;
           margin-right: 15px;
           cursor: pointer;
           accent-color: var(--accent);
       }}
       .checklist-label {{
           font-size: 1em;
           cursor: pointer;
           line-height: 1.4;
       }}
       .checklist-item.checked .checklist-label {{
           text-decoration: line-through;
           color: #888;
       }}
       .var-badge {{
           font-weight: bold;
           color: #555;
           margin-right: 5px;
       }}
       .team-tag {{
           background: #eee;
           padding: 2px 6px;
           border-radius: 4px;
           font-size: 0.85em;
           margin: 0 4px;
       }}
       .stake-tag {{
           margin-left: 10px;
           font-weight: bold;
           color: #2e7d32;
           background: #e8f5e9;
           padding: 2px 8px;
           border-radius: 4px;
       }}
   </style>
</head>
<body>
   <h1>‚ÑπÔ∏è –õ–µ–≥–µ–Ω–¥–∞ –ú–∞—Ç—á–µ–π:</h1>
   
   <div class="legend-card">
       <div class="match-header"><span class="icon">1Ô∏è‚É£</span> {m1} | üìÖ {m1_meta.get('date', '')}</div>
       <div class="match-info">üìù <strong>–°—Ü–µ–Ω–∞—Ä–∏–π:</strong> {m1_meta.get('reason', 'N/A')}</div>
   </div>
   <div class="legend-card">
       <div class="match-header"><span class="icon">2Ô∏è‚É£</span> {m2} | üìÖ {m2_meta.get('date', '')}</div>
       <div class="match-info">üìù <strong>–°—Ü–µ–Ω–∞—Ä–∏–π:</strong> {m2_meta.get('reason', 'N/A')}</div>
   </div>
   <div class="legend-card">
       <div class="match-header"><span class="icon">3Ô∏è‚É£</span> {m3} | üìÖ {m3_meta.get('date', '')}</div>
       <div class="match-info">üìù <strong>–°—Ü–µ–Ω–∞—Ä–∏–π:</strong> {m3_meta.get('reason', 'N/A')}</div>
   </div>

   <div class="checklist-container">
       <h2>üìã –ß–µ–∫-–ª–∏—Å—Ç –í–∞—Ä–∏–∞–Ω—Ç–æ–≤ (–û—Ç–º–µ—á–∞–π —Å–¥–µ–ª–∞–Ω–Ω—ã–µ):</h2>
"""
    for i, v in enumerate(variations):
        stake_html = ""
        if stakes and i < len(stakes):
            stake_html = f'<span class="stake-tag">üí∞ {stakes[i]:.0f} ‚ÇΩ</span>'
        
        row_html = f"""
       <div class="checklist-item" id="row_{i}">
          <input type="checkbox" onclick="toggleRow({i})">
          <label class="checklist-label" onclick="toggleRow({i})">
             <span class="var-badge">–í{i+1}:</span> 
             <span class="team-tag">1Ô∏è‚É£ {n1}</span> <b>{v[0]}</b> | 
             <span class="team-tag">2Ô∏è‚É£ {n2}</span> <b>{v[1]}</b> | 
             <span class="team-tag">3Ô∏è‚É£ {n3}</span> <b>{v[2]}</b>
             {stake_html}
          </label>
       </div>
       """
        html_content += row_html

    html_content += """
   </div>
   <script>
       function toggleRow(i) {
           const row = document.getElementById("row_" + i);
           const checkbox = row.querySelector("input[type='checkbox']");
           if (event.target !== checkbox) checkbox.checked = !checkbox.checked;
           if (checkbox.checked) row.classList.add("checked");
           else row.classList.remove("checked");
       }
   </script>
</body>
</html>
"""
    return html_content

def upload_to_beget(filename, content):
    """
    Uploads HTML to Beget via SFTP.
    """
    HOST = 'ttimbah0.beget.tech'
    USER = 'ttimbah0'
    PASS = '@@Ae32c1c5'
    REMOTE_DIR = '/home/t/ttimbah0/dev.5na5.ru/public_html/project/expbeg/snapshots'
    PUBLIC_URL = f"http://dev.5na5.ru/project/expbeg/snapshots/{filename}"
    
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(HOST, username=USER, password=PASS)
        
        ssh.exec_command(f"mkdir -p {REMOTE_DIR}")
        
        sftp = ssh.open_sftp()
        with sftp.open(f"{REMOTE_DIR}/{filename}", "w") as f:
            f.write(content)
        sftp.close()
        ssh.close()
        return PUBLIC_URL
    except Exception as e:
        print(f"Upload Error: {e}")
        return None

def send_telegram_message(token, chat_id, message):
    if not token or not chat_id: return False
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {"chat_id": chat_id, "text": message, "parse_mode": "Markdown"}
    try:
        requests.post(url, json=payload)
        return True
    except:
        return False
